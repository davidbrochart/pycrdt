{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Pycrdt is a Python CRDT library that provides bindings for Yrs, the Rust port of the Yjs framework.</p> <p>Conflict-free Replicated Data Types (CRDTs) allow creating shared documents that can automatically merge changes made concurrently on different \"copies\" of the data. When the data lives on different machines, they make it possible to build distributed systems that work with local data, leaving the synchronization and conflict resolution with remote data to the CRDT algorithm, which ensures that all data replicas eventually converge to the same state.</p> <p>Pycrdt is an alternative to Ypy. Their architectures differ in that pycrdt is a mixed Python/Rust project, while Ypy is Rust-only. This probably gives Ypy a performance gain, at the cost of complexity. Pycrdt is more Pythonic and its code base probably easier to understand and maintain. For more information, see the following GitHub issues:</p> <ul> <li>Move pycrdt to jupyter-server</li> <li>New Python bindings for Yrs</li> </ul>"},{"location":"install/","title":"Install","text":"<p>Pycrdt can be installed through PyPI or conda-forge.</p>"},{"location":"install/#with-pip","title":"With <code>pip</code>","text":"<pre><code>pip install pycrdt\n</code></pre>"},{"location":"install/#with-micromamba","title":"With <code>micromamba</code>","text":"<p>We recommend using <code>micromamba</code> to manage <code>conda-forge</code> environments (see <code>micromamba</code>'s installation instructions). First create an environment, here called <code>my_env</code>, and activate it: <pre><code>micromamba create -n my_env\nmicromamba activate my_env\n</code></pre> Then install <code>pycrdt</code>.</p> <pre><code>micromamba install -c conda-forge pycrdt\n</code></pre>"},{"location":"install/#development-install","title":"Development install","text":"<p>You first need to clone the repository: <pre><code>git clone https://github.com/jupyter-server/pycrdt.git\ncd pycrdt\n</code></pre> We recommend working in a conda environment. In order to build <code>pycrdt</code>, you will need <code>pip</code> and the Rust compiler: <pre><code>micromamba create -n pycrdt-dev\nmicromamba activate pycrdt-dev\nmicromamba install -c conda-forge pip rust\n</code></pre> Then install <code>pycrdt</code> in editable mode: <pre><code>pip install -e .\n</code></pre> This will build the Rust extension using maturin. If you make changes to the Python code only, you don't need to recompile anything, changes will be reflected the next time you run the Python interpreter. If you make changes to the Rust code, you need to recompile it but you don't need to reinstall <code>pycrdt</code>, you can just re-build the Rust extension with: <pre><code># install maturin only once:\npip install maturin\n# build the Rust extension each time the Rust code changes:\nmaturin develop\n</code></pre></p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#quickstart","title":"Quickstart","text":"<p>Pycrdt offers the following shared data types:</p> <ul> <li><code>Text</code>: a type similar to a <code>str</code>.</li> <li><code>Array</code>: a type similar to a <code>list</code>.</li> <li><code>Map</code>: a type similar to a <code>dict</code>.</li> </ul> <p>You can initialize them with their Python built-in counterparts:</p> <pre><code>from pycrdt import Text, Array, Map\n\ntext0 = Text(\"Hello\")\narray0 = Array([0, \"foo\"])\nmap0 = Map({\"key0\": \"value0\"})\n</code></pre> <p>But they are pretty useless on their own. They are just placeholders waiting to be inserted in a shared document. Only then do they really become useful:</p> <pre><code>from pycrdt import Doc\n\ndoc = Doc()\ndoc[\"text0\"] = text0\ndoc[\"array0\"] = array0\ndoc[\"map0\"] = map0\n</code></pre> <p>Now you can operate on them as you would expect, for instance:</p> <pre><code>text0 += \", World!\"\narray0.append(\"bar\")\nmap0[\"key1\"] = \"value1\"\n</code></pre> <p>Note that an <code>Array</code> and a <code>Map</code> can hold other shared data types:</p> <pre><code>map1 = Map({\"baz\": 1})\narray1 = Array([5, 6, 7])\n\narray0.append(map1)\nmap0[\"key2\"] = array1\n</code></pre> <p>Every change to <code>doc</code> (a modified/added/deleted value) will generate an update in the form of a binary encoded data. You can listen to these updates and send them on the wire, so that they can be applied to a remote document.</p> <p>You can also listen to changes on the individual shared data types (<code>text0</code>, <code>array1</code>, etc.) by registering callbacks, that will be called with the change event(s), so that your application can react to data changes.</p> <p>We say that <code>text0</code>, <code>array0</code> and <code>map0</code> are root types of <code>doc</code>. When they got inserted into <code>doc</code>, we gave them a name. For instance, <code>text0</code> was inserted under <code>\"text0\"</code>. This is how a remote document will retrieve the root types of the document, after applying the received updates:</p> <pre><code>update = doc.get_update()\n\n# the (binary) update could travel on the wire to a remote machine:\n\nremote_doc = Doc()\nremote_doc.apply_update(update)\n\nremote_doc[\"text0\"] = text0 = Text()\nremote_doc[\"array0\"] = array0 = Array()\nremote_doc[\"map0\"] = map0 = Map()\n</code></pre> <p>You could say that there is nothing fancy here, it's just about encoding data changes so that they can be applied on another object. But this is where the magic of CRDTs comes into play. Their algorithm ensures that if some changes are done concurrently on different objects representing the same data (for instance on different machines), applying the changes will lead to the same data on all objects. Without such algorithms, this property doesn't hold due to the fact that changes depend on the order in which they are applied, and that they take time to travel on the wire.</p> <p>The most common example is inserting a different character on a text editor on two machines. Say we start with a blank page on both editors, and the user on machine A inserts \"a\" at the same time the user on machine B inserts \"b\". After receiving the other user's update, if no special care is taken, machine A will show \"ba\" and machine B will show \"ab\". In other words, their document states will diverge, and thus users won't collaborate on the same document anymore. CRDTs ensure that documents don't diverge, their shared documents will eventually have the same state. It will arbitrary be \"ab\" or \"ba\", but it will be the same on both machines.</p>"},{"location":"usage/#transactions","title":"Transactions","text":"<p>Every change to a shared data happens in a document transaction, and there can only be one transaction at a time. Pycrdt offers two methods for creating transactions: - <code>doc.transaction()</code>: used with a context manager, this will create a new transaction if there is no current one, or use the current transaction. This method will never block, and should be used most of the time. - <code>doc.new_transaction()</code>: used with a context manager or an async context manager, this will always try to create a new transaction. This method can block, waiting for a transaction to be released.</p>"},{"location":"usage/#non-blocking-transactions","title":"Non-blocking transactions","text":"<p>When no current transaction exists, an implicit transaction is created. Grouping multiple changes in a single transaction makes them atomic: they will appear as done simultaneously rather than sequentially.</p> <pre><code>with doc.transaction():\n    text0 += \", World!\"\n    array0.append(\"bar\")\n    map0[\"key1\"] = \"value1\"\n</code></pre> <p>Transactions can be nested: when a transaction is created inside another one, changes will be made in the outer transaction. In the following example, all changes are made in transaction <code>t0</code>.</p> <pre><code>with doc.transaction() as t0:\n    text0 += \", World!\"\n    with doc.transaction() as t1:\n        array0.append(\"bar\")\n        with doc.transaction() as t2:\n            map0[\"key1\"] = \"value1\"\n</code></pre>"},{"location":"usage/#blocking-transactions","title":"Blocking transactions","text":""},{"location":"usage/#multithreading","title":"Multithreading","text":"<p>When used with a (non-async) context manager, the <code>new_transaction()</code> method will block the current thread waiting to acquire a transaction, with an optional timeout:</p> <pre><code>from threading import Thread\nfrom pycrdt import Doc\n\ndoc = Doc(allow_multithreading=True)\n\ndef create_new_transaction():\n    with doc.new_transaction(timeout=3):\n        ...\n\nt0 = Thread(target=create_new_transaction)\nt1 = Thread(target=create_new_transaction)\nt0.start()\nt1.start()\nt0.join()\nt1.join()\n</code></pre>"},{"location":"usage/#asynchronous-programming","title":"Asynchronous programming","text":"<p>When used with an async context manager, the <code>new_transaction()</code> method will yield to the event loop until a transaction is acquired:</p> <pre><code>from anyio import create_task_group, run\nfrom pycrdt import Doc\n\ndoc = Doc()\n\nasync def create_new_transaction():\n    async with doc.new_transaction(timeout=3):\n        ...\n\nasync def main():\n    async with create_task_group() as tg:\n        tg.start_soon(create_new_transaction)\n        tg.start_soon(create_new_transaction)\n\nrun(main)\n</code></pre>"},{"location":"usage/#events","title":"Events","text":""},{"location":"usage/#shared-data-events","title":"Shared data events","text":"<p>Changes to shared data can be observed in order to react on them. For instance, if a character is inserted in a <code>Text</code> data, a text editor should insert the character in the text shown to the user. This is done by registering callbacks.</p> <pre><code>from pycrdt import TextEvent\n\ndef handle_changes(event: TextEvent):\n    # process the event\n    ...\n\ntext0_subscription_id = text0.observe(handle_changes)\n</code></pre> <p>The subscription ID can be used to unregister the callback later.</p> <pre><code>text0.unobserve(text0_subscription_id)\n</code></pre> <p>For container data types like <code>Array</code> and <code>Map</code>, it can be useful to observe changes that are deeply nested in the hierarchy. For instance, you may want to observe all changes that happen in <code>array0</code>, including changes in <code>map1</code>:</p> <pre><code>array0:\n  - 0\n  - \"foo\"\n  - \"bar\"\n  - map1:\n    \"baz\": 1\n</code></pre> <p>Using the <code>observe</code> method will only notify for changes happening at the top-level of the container, for instance when the value at index 2 is deleted, but not for changes happening in <code>map1</code>. Use the <code>observe_deep</code> method instead, with a callback that accepts a list of events.</p> <pre><code>from pycrdt import ArrayEvent\n\ndef handle_deep_changes(events: list[ArrayEvent]):\n    # process the events\n    ...\n\narray0_subscription_id = array0.observe_deep(handle_deep_changes)\n</code></pre> <p>Unregistering the callback is done with the same <code>unobserve</code> method.</p>"},{"location":"usage/#document-events","title":"Document events","text":"<p>Observing changes made to a document is mostly meant to send the changes to another document, usually over the wire to a remote machine. Changes can be serialized to binary by getting the event's <code>update</code>:</p> <pre><code>from pycrdt import TransactionEvent\n\ndef handle_doc_changes(event: TransactionEvent):\n    update: bytes = event.update\n    # send binary update on the wire\n\ndoc.observe(handle_doc_changes)\n</code></pre> <p>Changes can be applied to a remote document at the other end of the wire:</p> <pre><code># receive binary update from e.g. a WebSocket\nupdate: bytes\n\nremote_doc.apply_update(update)\n</code></pre>"}]}